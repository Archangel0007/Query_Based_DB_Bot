{% extends "index.html" %}

{% block title %}Data Upload - Schema Builder{% endblock %}

{% block content %}
<div class="page-layout">
    <div class="sidebar-left">
        <h3>üñºÔ∏è Schema Preview</h3>
        <div id="schema-image-container" style="display: none;"></div>
    </div>
    <div class="main-content-right">
        <div id="status-bar">
            <div class="spinner" id="spinner"></div>
            <span id="status-text"></span>
        </div>

        <div class="form-container" id="form-container">
            <h3>Provide Data and Context</h3>
            <p><strong>Accepted Data Types:</strong> CSV, JSON, XLS, PDF/DOC, XML, Website/HTML, TXT</p>
            <form id="upload-form">
                <label for="data_medium">Select Data Source Medium:</label>
                <select id="data_medium" name="data_medium">
                    <option value="direct_file_drop">Direct File Drop</option>
                    <option value="sharepoint_link">SharePoint Link</option>
                    <option value="aws_dynamodb">AWS DynamoDB</option>
                    <option value="azure_cosmosdb">Azure Cosmos DB</option>
                    <option value="s3_bucket">S3 Bucket</option>
                    <option value="Website/HTML">Website/HTML</option>
                </select>

                <div id="direct_file_drop_input" class="medium-input-group">
                    <label for="csv_files">Upload File(s):</label>
                    <input type="file" id="csv_files" name="csv_files" multiple>
                </div>

                <div id="sharepoint_link_input" class="medium-input-group" style="display: none;">
                    <label for="sharepoint_link">SharePoint Link:</label>
                    <input type="text" id="sharepoint_link" name="sharepoint_link" placeholder="e.g., https://yourcompany.sharepoint.com/sites/data/file.xlsx">
                </div>

                <div id="website_input" class="medium-input-group" style="display: none;">
                    <label class="input-label" for="website_link">Website / HTML URL</label>
                    <input class="input-field" type="url" id="website_link" name="website_link" placeholder="https://example.com/">
                    <small class="muted">Provide a public URL to a page containing structured tables or data to extract.</small>
                </div>

                <div id="aws_dynamodb_input" class="medium-input-group" style="display: none;">
                    <div class="group-title">AWS DynamoDB (structured fields or connection string)</div>
                    <label class="input-label" for="dynamodb_table_name">Table name</label>
                    <input class="input-field" type="text" id="dynamodb_table_name" name="dynamodb_table_name" placeholder="e.g., orders">

                    <label class="input-label" for="dynamodb_region">Region</label>
                    <input class="input-field" type="text" id="dynamodb_region" name="dynamodb_region" placeholder="e.g., us-east-1">

                    <label class="input-label" for="dynamodb_access_key">AWS Access Key </label>
                    <input class="input-field" type="text" id="dynamodb_access_key" name="dynamodb_access_key" placeholder="Access key">

                    <label class="input-label" for="dynamodb_secret_key">AWS Secret Key </label>
                    <input class="input-field" type="password" id="dynamodb_secret_key" name="dynamodb_secret_key" placeholder="Secret key">

                    <!-- Connection string option removed: please fill structured fields above -->
                </div>

                <div id="azure_cosmosdb_input" class="medium-input-group" style="display: none;">
                    <div class="group-title">Azure Cosmos DB (structured fields or connection string)</div>
                    <label class="input-label" for="cosmos_uri">Cosmos URI</label>
                    <input class="input-field" type="text" id="cosmos_uri" name="cosmos_uri" placeholder="e.g., https://xxxx.documents.azure.com:443/">

                    <label class="input-label" for="cosmos_db">Database name</label>
                    <input class="input-field" type="text" id="cosmos_db" name="cosmos_db" placeholder="Database name">

                    <label class="input-label" for="cosmos_collection">Collection name</label>
                    <input class="input-field" type="text" id="cosmos_collection" name="cosmos_collection" placeholder="Collection name">

                    <!-- Connection string option removed: please fill structured fields above -->
                </div>

                <div id="s3_bucket_input" class="medium-input-group" style="display: none;">
                    <div class="group-title">S3 (structured fields or s3:// path)</div>
                    <label class="input-label" for="s3_bucket_name">Bucket name</label>
                    <input class="input-field" type="text" id="s3_bucket_name" name="s3_bucket_name" placeholder="e.g., my-bucket">

                    <label class="input-label" for="s3_object_key">Object key</label>
                    <input class="input-field" type="text" id="s3_object_key" name="s3_object_key" placeholder="e.g., path/to/file.csv">

                    <label class="input-label" for="s3_region">Region </label>
                    <input class="input-field" type="text" id="s3_region" name="s3_region" placeholder="e.g., us-east-1">

                    <label class="input-label" for="s3_access_key">S3 Access Key </label>
                    <input class="input-field" type="text" id="s3_access_key" name="s3_access_key" placeholder="Access key">

                    <label class="input-label" for="s3_secret_key">S3 Secret Key </label>
                    <input class="input-field" type="password" id="s3_secret_key" name="s3_secret_key" placeholder="Secret key">

                    <!-- Connection string/path option removed: please fill structured fields above -->
                </div>

                <label for="schema_context">Provide context about your schema (required):</label>
                <textarea id="schema_context" name="schema_context" rows="4" placeholder="e.g., A customer can have many orders. An order belongs to one customer." required></textarea>
                <button type="submit">Generate Dimensional Model</button>
            </form>

            <!-- Logs panel placed immediately after the Generate button as requested -->
            <div id="logs-wrapper" class="logs-wrapper" style="margin-top:12px;">
                <button id="logs-toggle-btn" class="btn">Show logs</button>
                <div id="logs-panel" style="display:none; margin-top:8px;">
                    <div id="logs-container" style="max-height:240px; overflow:auto; border:1px solid var(--border-color); padding:8px; background:var(--panel-bg-color); border-radius:4px;"></div>
                </div>
            </div>
        </div>
    
        <div id="chat-section" style="display: none;">
            <h2>üß† Schema Chat</h2>
            <div class="chat-container" id="chat-container">
                <!-- Chat messages will be injected here -->
            </div>
        </div>
        
    </div>
</div>
{% endblock %}

{% block scripts %}
    
<script>
        const form = document.getElementById('upload-form');
        const chatContainer = document.getElementById('chat-container');
        const statusText = document.getElementById('status-text');
        const spinner = document.getElementById('spinner');
        const formContainer = document.getElementById('form-container');
        const reviewContainer = document.getElementById('review-container');
        const chatSection = document.getElementById('chat-section');
        const schemaImageContainer = document.getElementById('schema-image-container');
        const logsToggleBtn = document.getElementById('logs-toggle-btn');
        const logsContainer = document.getElementById('logs-container');
        const logsWrapper = document.getElementById('logs-wrapper');

        window.schemaPromptActive = false;


        // Helper to insert an element after a reference node
        function insertAfter(newNode, referenceNode) {
            referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
        }

        // Move logs under the chat container when chat is visible; otherwise keep logs below the generate form
        function relocateLogs() {
            try {
                // If chatSection is visible (pipeline in motion), move logs below chat container
                if (chatSection && chatSection.style.display && chatSection.style.display !== 'none') {
                    // ensure logsWrapper sits right after the chat container
                    if (logsWrapper && chatContainer && chatContainer.parentNode) {
                        insertAfter(logsWrapper, chatContainer);
                    }
                } else {
                    // keep logs inside the form container, directly after the form
                    if (logsWrapper && form && form.parentNode) {
                        insertAfter(logsWrapper, form);
                    }
                }
            } catch (err) {
                console.error('relocateLogs error', err);
            }
        }
        const submitReviewBtn = document.getElementById('submit-review-btn');
    
    const dataMediumSelect = document.getElementById('data_medium');
    const directFileDropInput = document.getElementById('direct_file_drop_input');
    const sharepointLinkInput = document.getElementById('sharepoint_link_input');
    const websiteInput = document.getElementById('website_input');
    const awsDynamoDBInput = document.getElementById('aws_dynamodb_input');
    const azureCosmosDBInput = document.getElementById('azure_cosmosdb_input');
    const s3BucketInput = document.getElementById('s3_bucket_input');

        let taskId = null;
        let pollingInterval = null;
        let scriptApprovalShown = false;
        window.schemaCorrectionOpen = window.schemaCorrectionOpen || false; // global flag used by prompts/polling

    function showSelectedMediumInput() {
        // Hide all input groups first
        directFileDropInput.style.display = 'none';
        sharepointLinkInput.style.display = 'none';
        websiteInput.style.display = 'none';
        awsDynamoDBInput.style.display = 'none';
        azureCosmosDBInput.style.display = 'none';
        s3BucketInput.style.display = 'none';

        // Show the selected one
        switch (dataMediumSelect.value) {
            case 'direct_file_drop':
                directFileDropInput.style.display = 'block';
                break;
            case 'sharepoint_link':
                sharepointLinkInput.style.display = 'block';
                break;
            case 'Website/HTML':
                websiteInput.style.display = 'block';
                break;
            case 'aws_dynamodb':
                awsDynamoDBInput.style.display = 'block';
                break;
            case 'azure_cosmosdb':
                azureCosmosDBInput.style.display = 'block';
                break;
            case 's3_bucket':
                s3BucketInput.style.display = 'block';
                break;
        }
    }

    // Initial call to set the correct visibility on page load
    showSelectedMediumInput();

    // Initialize logs panel: hide container and wire toggle button
    if (logsToggleBtn && logsContainer) {
        const logsPanel = document.getElementById('logs-panel');
        // start hidden
        logsPanel.style.display = 'none';
        logsContainer.style.display = 'block'; // container inside panel should be visible when panel is shown
        logsToggleBtn.textContent = 'Show logs';
        logsToggleBtn.addEventListener('click', () => {
            if (logsPanel.style.display === 'none') {
                logsPanel.style.display = 'block';
                logsToggleBtn.textContent = 'Hide logs';
            } else {
                logsPanel.style.display = 'none';
                logsToggleBtn.textContent = 'Show logs';
            }
        });
    }

    // Ensure logs start in the correct location on page load
    relocateLogs();

    // Add event listener for changes in the dropdown
    dataMediumSelect.addEventListener('change', showSelectedMediumInput);

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
        const submitButton = form.querySelector('button');
        submitButton.disabled = true;
            statusText.textContent = 'Uploading files...';
            spinner.style.display = 'inline-block';

        const formData = new FormData();
        formData.append('schema_context', document.getElementById('schema_context').value);
        formData.append('data_medium', dataMediumSelect.value);

        let source_provided = false;

        // Append data based on selected medium
        switch (dataMediumSelect.value) {
            case 'direct_file_drop':
                const files = document.getElementById('csv_files').files;
                if (files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        formData.append('csv_files', files[i]);
                    }
                    source_provided = true;
                }
                break;
            case 'sharepoint_link':
                const sharepointLink = document.getElementById('sharepoint_link').value;
                if (sharepointLink.trim()) {
                    formData.append('sharepoint_link', sharepointLink);
                    source_provided = true;
                }
                break;
            case 'aws_dynamodb':
                // Only structured fields supported now
                const dynamodbTable = document.getElementById('dynamodb_table_name').value;
                const dynamodbRegion = document.getElementById('dynamodb_region').value;
                const dynamodbAccessKey = document.getElementById('dynamodb_access_key').value;
                const dynamodbSecretKey = document.getElementById('dynamodb_secret_key').value;

                if (dynamodbTable.trim()) {
                    formData.append('dynamodb_table_name', dynamodbTable.trim());
                    if (dynamodbRegion.trim()) formData.append('dynamodb_region', dynamodbRegion.trim());
                    if (dynamodbAccessKey.trim()) formData.append('dynamodb_access_key', dynamodbAccessKey.trim());
                    if (dynamodbSecretKey.trim()) formData.append('dynamodb_secret_key', dynamodbSecretKey.trim());
                    source_provided = true;
                }
                break;
            case 'azure_cosmosdb':
                // Only structured fields supported now
                const cosmosUri = document.getElementById('cosmos_uri').value;
                const cosmosDb = document.getElementById('cosmos_db').value;
                const cosmosCollection = document.getElementById('cosmos_collection').value;

                if (cosmosUri.trim() && cosmosDb.trim() && cosmosCollection.trim()) {
                    formData.append('cosmos_uri', cosmosUri.trim());
                    formData.append('cosmos_db', cosmosDb.trim());
                    formData.append('cosmos_collection', cosmosCollection.trim());
                    source_provided = true;
                }
                break;
            case 'Website/HTML':
                // Website URL input
                const websiteLink = document.getElementById('website_link').value;
                if (websiteLink && websiteLink.trim()) {
                    formData.append('website_link', websiteLink.trim());
                    source_provided = true;
                }
                break;
            case 's3_bucket':
                // Only structured fields supported now
                const s3BucketName = document.getElementById('s3_bucket_name').value;
                const s3ObjectKey = document.getElementById('s3_object_key').value;
                const s3Region = document.getElementById('s3_region').value;
                const s3AccessKey = document.getElementById('s3_access_key').value;
                const s3SecretKey = document.getElementById('s3_secret_key').value;

                if (s3BucketName.trim() && s3ObjectKey.trim()) {
                    formData.append('s3_bucket_name', s3BucketName.trim());
                    formData.append('s3_object_key', s3ObjectKey.trim());
                    if (s3Region.trim()) formData.append('s3_region', s3Region.trim());
                    if (s3AccessKey.trim()) formData.append('s3_access_key', s3AccessKey.trim());
                    if (s3SecretKey.trim()) formData.append('s3_secret_key', s3SecretKey.trim());
                    source_provided = true;
                }
                break;
        }

        if (!source_provided || !document.getElementById('schema_context').value.trim()) {
            alert('Please provide a data source and the required schema context.');
            submitButton.disabled = false;
            spinner.style.display = 'none';
            return;
        }

            const response = await fetch('/start_generation', {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                taskId = data.task_id;
                formContainer.style.display = 'none';
                chatSection.style.display = 'block'; // Show chat after upload
                // Move logs to sit beneath the chat container now that pipeline is running
                relocateLogs();
                pollingInterval = setInterval(pollStatus, 2000);
            } else {
            const errorData = await response.json();
            alert('Error starting generation: ' + (errorData.error || 'Unknown error'));
            submitButton.disabled = false;
                spinner.style.display = 'none';
                // Ensure logs remain with the form if generation failed
                relocateLogs();
            }
        });

        submitReviewBtn.addEventListener('click', async () => {
            const feedback = document.getElementById('review-feedback').value;
            submitReviewBtn.disabled = true;

            try {
                const res = await fetch(`/submit_review/${taskId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ feedback: feedback })
                });

                const data = await res.json();
                if (!res.ok) {
                    alert('Error submitting feedback: ' + (data.error || 'Unknown error'));
                    submitReviewBtn.disabled = false;
                    return;
                }

                // hide review box and immediately poll status to update UI
                reviewContainer.style.display = 'none';
                document.getElementById('review-feedback').value = '';
                pollStatus();
            } catch (err) {
                alert('Network error submitting feedback: ' + err.message);
                submitReviewBtn.disabled = false;
            }
        });

        function showImageModal(src) {
            // Remove existing modal if any
            const existingModal = document.querySelector('.modal-overlay');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal elements
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';

            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';

            const modalImage = document.createElement('img');
            modalImage.src = src;

            const closeModalBtn = document.createElement('button');
            closeModalBtn.className = 'modal-close';
            closeModalBtn.innerHTML = '&times;'; // 'x' symbol

            // Assemble modal
            modalContent.appendChild(modalImage);
            modalContent.appendChild(closeModalBtn);
            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);

            // Add event listeners to close the modal
            const closeModal = () => modalOverlay.remove();
            closeModalBtn.addEventListener('click', closeModal);
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) closeModal(); // Close only if clicking on the background
            });
        }

        function addChatMessage(role, htmlContent, insertAfterEl = null) {
    const msgDiv = document.createElement('div');
    msgDiv.className = `chat-msg ${role}`;
    msgDiv.innerHTML = htmlContent;

    // If a reference element is given, insert after it; otherwise append to end
    if (insertAfterEl && insertAfterEl.parentNode === chatContainer) {
        insertAfterEl.insertAdjacentElement('afterend', msgDiv);
    } else {
        chatContainer.appendChild(msgDiv);
    }

    // Scroll only if new message is at the bottom
    if (!insertAfterEl) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    return msgDiv;
}


        // helper: compute a short snippet from an assistant message DOM node
function getAssistantSnippet(assistantMsgDiv) {
    if (!assistantMsgDiv) return '';
    // find the assistant text portion (strip labels like "Assistant" or "You")
    const txt = assistantMsgDiv.innerText || '';
    // remove the leading "Assistant" or "You" if present
    const parts = txt.split('\n').slice(1); // safe: first line is the label
    const joined = parts.join(' ').trim();
    return joined.substring(0, 60); // first 60 chars as a fingerprint/snippet
}


function showSchemaApprovalPrompt(schemaText) {
    // Guard to prevent multiple schema prompts from stacking
    if (window.schemaPromptActive || window.schemaCorrectionOpen) return;
    window.schemaPromptActive = true;
        // guard: don't create duplicate schema prompt or create while correction UI open
    if (document.querySelector('#schema-ok-btn') || window.schemaCorrectionOpen) {
        // either already shown, or user is editing a correction -> do nothing
        return;
    }

    const msg = `
        <b>Assistant:</b><br>
        Please review the schema below:<br><pre>${schemaText}</pre>
        <div style="margin-top:8px;">
            <button id="schema-ok-btn" class="btn">‚úÖ Okay</button>
            <button id="schema-notok-btn" class="btn">‚ùå Not okay</button>
        </div>
    `;
    const msgDiv = addChatMessage('assistant', msg);

    // --- helper for retry-based feedback POST ---
    async function sendReviewWithRetries(action, details = '', attempt = 0) {
        if (!taskId) return { ok: false, err: 'no_taskid' };
        const maxAttempts = 3;
        const backoffs = [500, 1200, 2500];

        try {
            const res = await fetch(`/submit_review/${taskId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action, details })
            });
            if (res.ok) {
                const payload = await res.json().catch(()=>null);
                return { ok: true, payload };
            } else {
                const txt = await res.text().catch(()=>'<no-body>');
                console.warn('submit_review non-ok', res.status, txt);
            }
        } catch (err) {
            console.warn('submit_review network error', err);
        }

        if (attempt + 1 < maxAttempts) {
            await new Promise(r => setTimeout(r, backoffs[attempt] || 1000));
            return sendReviewWithRetries(action, details, attempt + 1);
        }

        return { ok: false, err: 'all_attempts_failed' };
    }

    // --- pause polling if correction UI open ---
    if (!window._pollStatusOriginal) {
        window._pollStatusOriginal = window.pollStatus;
        window.pollStatus = async function() {
            if (window.schemaCorrectionOpen) return;
            return window._pollStatusOriginal.apply(this, arguments);
        };
    }

    // ===== ‚úÖ OK button =====
    const okBtn = msgDiv.querySelector('#schema-ok-btn');
    okBtn.addEventListener('click', async () => {
        window.schemaPromptActive = false;
        okBtn.disabled = true;
        const existingCorrection = document.getElementById('schema-correction-area');
        if (existingCorrection) existingCorrection.remove();
        window.schemaCorrectionOpen = false;

        // create optimistic user message and insert it immediately after the assistant prompt
    //const userMsg = addChatMessage('user', '‚úÖ Okay', msgDiv);
    //userMsg.classList.add('local-msg', 'pending-review');
    // attach snippet so pollStatus can re-insert in the right place later
    //userMsg.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);
    // move it to appear right after the assistant message (better UX)
    //morag msgDiv.insertAdjacentElement('afterend', userMsg);
    // Skip showing "‚úÖ Okay" visually but keep all logic
const userMsg = document.createElement('div');
userMsg.classList.add('local-msg', 'pending-review');
userMsg.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);



        const res = await sendReviewWithRetries('approve');
        if (res.ok) {
            userMsg.classList.remove('pending-review');
            userMsg.classList.add('confirmed-review');
            try { await pollStatus(); } catch(e){ console.warn(e); }
            if (!pollingInterval) pollingInterval = setInterval(pollStatus, 2000);
        } else {
            userMsg.classList.remove('pending-review');
            userMsg.classList.add('failed-notify');
            const hint = document.createElement('span');
            hint.className = 'muted';
            hint.textContent = ' (failed to notify server)';
            userMsg.appendChild(hint);

            const retryBtn = document.createElement('button');
            retryBtn.className = 'btn small';
            retryBtn.textContent = 'Retry notify';
            retryBtn.style.marginLeft = '8px';
            userMsg.appendChild(retryBtn);

            retryBtn.addEventListener('click', async () => {
                retryBtn.disabled = true; retryBtn.textContent = 'Retrying...';
                const r2 = await sendReviewWithRetries('approve');
                if (r2.ok) {
                    userMsg.classList.remove('failed-notify');
                    userMsg.classList.add('confirmed-review');
                    retryBtn.remove(); hint.remove();
                    try { await pollStatus(); } catch(e){ console.warn(e); }
                } else {
                    retryBtn.disabled = false; retryBtn.textContent = 'Retry notify';
                }
            });
        }
    });

    // ===== ‚ùå NOT OK button =====
    const notOkBtn = msgDiv.querySelector('#schema-notok-btn');
    notOkBtn.addEventListener('click', () => {
        // prevent duplicates
        if (document.getElementById('schema-correction-area')) {
            document.getElementById('schema-correction-text').focus();
            return;
        }

        // show quick local "Not okay" message
        // morag const notOkMsg = addChatMessage('user', '‚ùå Not okay', msgDiv);
        //notOkMsg.classList.add('local-msg');
       // notOkMsg.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);
       // msgDiv.insertAdjacentElement('afterend', notOkMsg);
         
       // Skip showing "‚ùå Not okay" visually but keep tracking context
        const notOkMsg = document.createElement('div');
        notOkMsg.classList.add('local-msg');
        notOkMsg.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);


        // mark correction area open (pauses polling)
        window.schemaCorrectionOpen = true;

        const correctionArea = document.createElement('div');
        correctionArea.id = 'schema-correction-area';
        correctionArea.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);
        correctionArea.classList.add('local-msg'); // ensure pollStatus preserves it
        correctionArea.style.margin = '8px 0';
        correctionArea.innerHTML = `
            <textarea id="schema-correction-text" rows="3" style="width:100%;" placeholder="Please specify corrections..."></textarea>
            <div style="margin-top:6px;">
                <button id="schema-correction-submit" class="btn">Submit correction</button>
                <button id="schema-correction-cancel" class="btn">Cancel</button>
            </div>
        `;
        chatContainer.appendChild(correctionArea);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        document.getElementById('schema-correction-text').focus();

        // --- Submit correction ---
        correctionArea.querySelector('#schema-correction-submit').addEventListener('click', async () => {
            window.schemaPromptActive = false;
            const txt = document.getElementById('schema-correction-text').value.trim();
            if (!txt) { alert('Please enter your corrections before submitting.'); return; }

            const userCorrectionMsg = addChatMessage('user', txt);
            userCorrectionMsg.classList.add('local-msg', 'pending-review');

            correctionArea.remove();
            window.schemaCorrectionOpen = false;

            const r = await sendReviewWithRetries('correct', txt);
            if (r.ok) {
                userCorrectionMsg.classList.remove('pending-review');
                userCorrectionMsg.classList.add('confirmed-review');
                try { await pollStatus(); } catch(e){ console.warn(e); }
                if (!pollingInterval) pollingInterval = setInterval(pollStatus, 2000);
            } else {
                userCorrectionMsg.classList.remove('pending-review');
                userCorrectionMsg.classList.add('failed-notify');

                const hint = document.createElement('span');
                hint.className = 'muted';
                hint.textContent = ' (failed to notify server)';
                userCorrectionMsg.appendChild(hint);

                const retryBtn = document.createElement('button');
                retryBtn.className = 'btn small';
                retryBtn.textContent = 'Retry notify';
                retryBtn.style.marginLeft = '8px';
                userCorrectionMsg.appendChild(retryBtn);

                retryBtn.addEventListener('click', async () => {
                    retryBtn.disabled = true; retryBtn.textContent = 'Retrying...';
                    const r2 = await sendReviewWithRetries('correct', txt);
                    if (r2.ok) {
                        userCorrectionMsg.classList.remove('failed-notify');
                        userCorrectionMsg.classList.add('confirmed-review');
                        retryBtn.remove(); hint.remove();
                        try { await pollStatus(); } catch(e){ console.warn(e); }
                    } else {
                        retryBtn.disabled = false; retryBtn.textContent = 'Retry notify';
                    }
                });
            }
        });

        // --- Cancel correction ---
        correctionArea.querySelector('#schema-correction-cancel').addEventListener('click', () => {
    window.schemaPromptActive = false;
    correctionArea.remove();
    window.schemaCorrectionOpen = false;
    // Keep "‚ùå Not okay" visible but allow reopening correction box
    const reopenBtn = document.createElement('button');
    reopenBtn.className = 'btn small';
    reopenBtn.textContent = '‚úèÔ∏è Reopen correction';
    reopenBtn.style.marginLeft = '8px';
    reopenBtn.onclick = () => {
        reopenBtn.remove();
        notOkBtn.click(); // triggers the correction box again
    };
    notOkMsg.appendChild(reopenBtn);
    try { pollStatus(); } catch(e){ console.warn(e); }
});

    });
}


function showScriptApprovalPrompt(type) {
    const msg = `
        <b>Assistant:</b><br>
        Please review the ${type === 'create' ? 'CREATE TABLE' : 'INSERT INTO'} script.<br>
        <div style="margin-top:8px;">
            <button id="view-script-btn" class="btn">üëÅÔ∏è View Script</button>
            <button id="approve-script-btn" class="btn">‚úÖ Approve</button>
        </div>
    `;
    const msgDiv = addChatMessage('assistant', msg);
        // guard so pollStatus won't create another prompt while one is visible
    //scriptApprovalShown = true;
    msgDiv.querySelector('#view-script-btn').addEventListener('click', () => {
        window.open(`/view_script/${taskId}/${type}`, '_blank', 'noopener');
    });

    // helper: try sending approval to server with two endpoint patterns and retries
    async function sendApprovalWithRetries(attempt = 0) {
        if (!taskId) {
            console.error('No taskId available for approval');
            return { ok: false, err: 'no_taskid' };
        }

        const endpoints = [
            { url: `/approve_script/${taskId}/${type}`, opts: { method: 'POST' } },
            { url: `/approve_action/${taskId}`, opts: { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: type }) } }
        ];

        // try endpoints sequentially on each attempt
        for (let ep of endpoints) {
            try {
                console.debug(`Approval attempt ${attempt+1}: POST ${ep.url}`);
                const res = await fetch(ep.url, ep.opts);
                if (res.ok) {
                    const payload = await res.json().catch(()=>null);
                    console.debug('Approval succeeded at', ep.url, 'payload=', payload);
                    return { ok: true, url: ep.url, payload };
                } else {
                    const txt = await res.text().catch(()=>'<no-body>');
                    console.warn('Approval endpoint returned non-ok', ep.url, res.status, txt);
                    // continue to fallback endpoint
                }
            } catch (err) {
                console.warn('Approval network error for', ep.url, err);
                // continue to fallback endpoint
            }
        }

        // if we reached here, this attempt failed ‚Äî maybe retry
        if (attempt < 2) {
            // exponential-ish backoff
            const backoffs = [500, 1200, 2500];
            await new Promise(r => setTimeout(r, backoffs[attempt] || 1000));
            return sendApprovalWithRetries(attempt + 1);
        }

        // final failure
        return { ok: false, err: 'all_attempts_failed' };
    }

    msgDiv.querySelector('#approve-script-btn').addEventListener('click', async () => {
        // Protect from double clicks
        const btn = msgDiv.querySelector('#approve-script-btn');
        btn.disabled = true;

        // Immediately add optimistic local user message so user sees feedback
       // const userMsgDiv = addChatMessage('user', '‚úÖ Approved', msgDiv);
       // userMsgDiv.classList.add('local-msg', 'pending-approve');
        //userMsgDiv.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);
        // morag msgDiv.insertAdjacentElement('afterend', userMsgDiv);
        // Skip showing the "‚úÖ Approved" message but keep functionality working
        const userMsgDiv = document.createElement('div');
        userMsgDiv.classList.add('local-msg', 'pending-approve');
        userMsgDiv.dataset.insertAfterSnippet = getAssistantSnippet(msgDiv);
// Not inserted into DOM ‚Äî internal tracking only


        // Attempt to notify server with retries
        const result = await sendApprovalWithRetries(0);

        if (result.ok) {
            // success -> mark local message confirmed, re-poll to get server-side log
            userMsgDiv.classList.remove('pending-approve');
            userMsgDiv.classList.add('confirmed-approve');
            try {
                // call pollStatus() to immediately sync; if pollingInterval is stopped, restart it
                await pollStatus();
                if (!pollingInterval) {
                    pollingInterval = setInterval(pollStatus, 2000);
                }
            } catch (err) {
                console.warn('poll after approve failed', err);
            }
            if (result.ok) {
    userMsgDiv.classList.remove('pending-approve');
    userMsgDiv.classList.add('confirmed-approve');
    try {
        await pollStatus();
        if (!pollingInterval) { pollingInterval = setInterval(pollStatus, 2000); }
    } catch (err) { console.warn('poll after approve failed', err); }
    // release guard so new approvals later can appear
    scriptApprovalShown = false;
}

            
        } else {
            // failure -> keep local message but mark failed and present retry UI
            userMsgDiv.classList.remove('pending-approve');
            userMsgDiv.classList.add('failed-notify');

            // show small inline retry button for this message
            const retryBtn = document.createElement('button');
            retryBtn.className = 'btn small';
            retryBtn.textContent = 'Retry notify';
            retryBtn.style.marginLeft = '8px';
            userMsgDiv.appendChild(retryBtn);

            retryBtn.addEventListener('click', async () => {
                retryBtn.disabled = true;
                retryBtn.textContent = 'Retrying...';
                // attempt again
                const r2 = await sendApprovalWithRetries(0);
                if (r2.ok) {
                    userMsgDiv.classList.remove('failed-notify');
                    userMsgDiv.classList.add('confirmed-approve');
                    retryBtn.remove();
                    // re-sync
                    try { await pollStatus(); } catch (e) { console.warn(e); }
                } else {
                    retryBtn.disabled = false;
                    retryBtn.textContent = 'Retry notify';
                    console.warn('Retry failed', r2.err || r2);
                }
            });

            // set visual hint to user
            const hint = document.createElement('span');
            hint.className = 'muted';
            hint.style.marginLeft = '8px';
            hint.textContent = ' (failed to notify server)';
            userMsgDiv.appendChild(hint);

            console.warn('Approval: failed to notify server after retries');
        }
    });
}

    async function pollStatus() {
     if (window.schemaPromptActive || window.schemaCorrectionOpen) return;
    if (!taskId) return;

    // --- Preserve any local-only user messages (so they won't get wiped out) ---
    const localNodes = [];
    chatContainer.querySelectorAll('.local-msg').forEach(node => {
        localNodes.push(node.cloneNode(true)); // clone to reinsert later
    });

    // Before clearing the UI, record which reasoning panels were open.
    const openReasoningIds = new Set();
    document.querySelectorAll('.reasoning-panel').forEach(panel => {
        if (panel.style.display === 'block') {
            openReasoningIds.add(panel.id);
        }
    });

    // --- Fetch status (network-safe) ---
    let response, data;
    try {
        response = await fetch(`/status/${taskId}`, { cache: 'no-store' });
    } catch (err) {
        console.warn('pollStatus: network error fetching status', err);
        showServerDownAlert();
        // don't attempt to render chat; return early
        return;
    }

    if (!response.ok) {
        console.warn('pollStatus: non-OK response', response.status);
        if (response.status >= 500) showServerDownAlert();
        return;
    }

    try {
        data = await response.json();
    } catch (err) {
        console.warn('pollStatus: failed to parse JSON', err);
        showServerDownAlert();
        return;
    }

    // Update status text & spinner
    statusText.textContent = data.status || '';
    if (data.status === 'Completed' || (data.status && data.status.startsWith && data.status.startsWith('Error'))) {
        spinner.style.display = 'none';
        if (typeof pollingInterval !== 'undefined' && pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    } else {
        spinner.style.display = 'inline-block';
    }

    // ---------------- Render chat from server logs (fresh)
    // IMPORTANT: if the correction UI is open, skip rebuilding the chat area
    // (we will still update logs + schema image below).
    if (!window.schemaCorrectionOpen) {
        try {
            chatContainer.innerHTML = ''; // Clear previous logs (we will re-append local afterwards)

            const serverLogs = data.logs || [];
            const existingUserTexts = [];

            serverLogs.forEach((msg, index) => {
                const msgDiv = document.createElement('div');
                msgDiv.className = `chat-msg ${msg.role || ''}`;

                const safeText = (msg.text || '').replace(/\n/g, '<br>');
                let contentHTML = `<b>${msg.role === 'user' ? 'You' : 'Assistant'}</b><br>${safeText}`;

                // save user text for dedupe
                if (msg.role === 'user') {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = safeText;
                    existingUserTexts.push(tempDiv.innerText.trim());
                }

                // reasoning panel support
                if (msg.reasoning && msg.reasoning.length > 0) {
                    const reasoningId = `reasoning-${index}`;
                    const isOpen = openReasoningIds.has(reasoningId);
                    const buttonText = isOpen ? 'Hide reasoning' : 'Show reasoning';
                    const panelStyle = isOpen ? 'display:block;' : 'display:none;';

                    contentHTML += ` <button class="reasoning-toggle-btn" data-target="${reasoningId}">${buttonText}</button>`;

                    let reasoningHTML = '';
                    if (Array.isArray(msg.reasoning) && msg.reasoning.length > 0 && msg.reasoning[0].step && msg.reasoning[0].details) {
                        reasoningHTML = msg.reasoning.map(item => `
                            <div class="reasoning-item">
                                <div class="reasoning-step">${item.step}</div>
                                <p class="reasoning-details">${item.details}</p>
                            </div>
                        `).join('');
                    } else {
                        reasoningHTML = `<pre>${JSON.stringify(msg.reasoning, null, 2)}</pre>`;
                    }

                    contentHTML += `<div id="${reasoningId}" class="reasoning-panel" style="${panelStyle}">${reasoningHTML}</div>`;
                }

                msgDiv.innerHTML = contentHTML;
                chatContainer.appendChild(msgDiv);
            });

            // Wire reasoning toggle buttons (avoid adding duplicate listeners)
            document.querySelectorAll('.reasoning-toggle-btn').forEach(btn => {
                if (!btn._wired) {
                    btn._wired = true;
                    btn.addEventListener('click', () => {
                        const targetId = btn.getAttribute('data-target');
                        const panel = document.getElementById(targetId);
                        if (!panel) return;
                        const isVisible = panel.style.display === 'block';
                        panel.style.display = isVisible ? 'none' : 'block';
                        btn.textContent = isVisible ? 'Show reasoning' : 'Hide reasoning';
                    });
                }
            });

            // Re-append preserved local nodes, but dedupe
            localNodes.forEach(clone => {
    // normalize clone text for dedupe
    const temp = document.createElement('div');
    temp.innerHTML = clone.innerHTML;
    const cloneText = temp.innerText.trim();

    if (existingUserTexts.includes(cloneText)) {
        return; // server already recorded it
    }

    // prefer inserting near the assistant prompt if we have a snippet
    const snippet = clone.dataset && clone.dataset.insertAfterSnippet;
    if (snippet) {
        // find a candidate assistant message that includes the snippet
        const assistantCandidates = Array.from(chatContainer.querySelectorAll('.chat-msg'))
            .filter(n => {
                // identify assistant messages: check first bold label or innerText first token
                const b = n.querySelector('b');
                if (b && b.innerText.toLowerCase().includes('assistant')) return true;
                // fallback: if element isn't user-labeled, consider it assistant
                return !b || (b && !b.innerText.toLowerCase().includes('you'));
            });

        const target = assistantCandidates.find(n => (n.innerText || '').includes(snippet));
        if (target) {
            // insert right after the matching assistant message
            target.insertAdjacentElement('afterend', clone);
            // ensure marker stays for future polls
            clone.classList.add('local-msg');
            return;
        }
    }

    // fallback to appending at end
    clone.classList.add('local-msg');
    chatContainer.appendChild(clone);
});


            chatContainer.scrollTop = chatContainer.scrollHeight;

        } catch (err) {
            console.error('Error while updating chat in pollStatus:', err);
        }
    } else {
        // If correction UI is open, don't rebuild chat. Re-append any preserved local nodes
        // that might not exist in the DOM yet (dedupe by text).
        try {
            const serverLogs = data.logs || [];
            const existingUserTexts = [];
            serverLogs.forEach(msg => {
                if (msg.role === 'user') {
                    const temp = document.createElement('div');
                    temp.innerHTML = (msg.text || '').replace(/\n/g, '<br>');
                    existingUserTexts.push(temp.innerText.trim());
                }
            });

            localNodes.forEach(clone => {
                const temp = document.createElement('div');
                temp.innerHTML = clone.innerHTML;
                const cloneText = temp.innerText.trim();
                if (!existingUserTexts.includes(cloneText)) {
                    clone.classList.add('local-msg');
                    chatContainer.appendChild(clone);
                }
            });

            chatContainer.scrollTop = chatContainer.scrollHeight;
        } catch (err) {
            console.warn('Error while preserving local nodes during correction:', err);
        }
    }

    // ---------- Update logs panel (system logs) ----------
    try {
        if (logsContainer) {
            logsContainer.innerHTML = '';
            const logs = data.system_logs || [];
            if (logs.length === 0) {
                const none = document.createElement('div');
                none.className = 'muted';
                none.textContent = 'No logs available yet.';
                logsContainer.appendChild(none);
            } else {
                logs.forEach(l => {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    const hdr = document.createElement('div');
                    hdr.className = 'log-header';
                    const ts = document.createElement('span');
                    ts.className = 'log-ts';
                    ts.textContent = l.time ? new Date(l.time).toLocaleString() : '';
                    hdr.appendChild(ts);
                    const body = document.createElement('pre');
                    body.textContent = l.text || '';
                    body.style.whiteSpace = 'pre-wrap';
                    entry.appendChild(hdr);
                    entry.appendChild(body);
                    logsContainer.appendChild(entry);
                });
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }
        }
    } catch (err) {
        console.warn('Error updating logs panel:', err);
    }

    // ---------- Schema image ----------
    try {
        if (data.schema_image_url) {
            const imageUrl = `${data.schema_image_url}?t=${new Date().getTime()}`;
            let img = schemaImageContainer.querySelector('img');
            if (!img) {
                schemaImageContainer.innerHTML = `<img src="${imageUrl}" alt="Generated Schema">`;
                img = schemaImageContainer.querySelector('img');
                img.addEventListener('click', () => showImageModal(imageUrl));
            } else {
                if (img.src !== imageUrl) img.src = imageUrl;
            }
            schemaImageContainer.style.display = 'block';
        }
    } catch (err) {
        console.warn('Error updating schema image:', err);
    }

    
       // --- Chat-based Approvals (schema review) ---
try {
    // if server wants schema review and we don't already have one shown, show it
    if (data.status === 'Awaiting user review' && !document.querySelector('#schema-ok-btn') && !window.schemaCorrectionOpen) {
        const schemaText = data.latest_schema || '';
        showSchemaApprovalPrompt(schemaText);
        submitReviewBtn.disabled = false;
    }

    // handle script create/insert approvals (guarded)
    const currentAwaiting = data.awaiting_approval || null;
    if (currentAwaiting && !scriptApprovalShown) {
        showScriptApprovalPrompt(currentAwaiting);
        // scriptApprovalShown is now set inside showScriptApprovalPrompt()
    }

    // if server no longer needs approval, reset the guard so future approvals can show
    if (!currentAwaiting) {
        scriptApprovalShown = false;
    }
} catch (err) {
    console.warn('Error handling approval UI:', err);
}



}

        
function showServerDownAlert() {
    // avoid duplicates
    if (document.querySelector('#server-down-alert')) return;

    const alertDiv = document.createElement('div');
    alertDiv.id = 'server-down-alert';
    alertDiv.className = 'chat-msg assistant';
    // inline styles so you see it quickly ‚Äî move to CSS if you prefer
    alertDiv.style.background = '#fff3cd';
    alertDiv.style.border = '1px solid #ffd966';
    alertDiv.style.color = '#7a4b00';
    alertDiv.style.padding = '10px';
    alertDiv.style.marginTop = '10px';
    alertDiv.style.borderRadius = '8px';
    alertDiv.innerHTML = `
        <b>‚ö†Ô∏è Server Disconnected</b><br>
        The backend server appears to be offline. Please restart the Flask app if you stopped it.<br>
        We'll keep trying to reconnect automatically.
    `;
    chatContainer.appendChild(alertDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;

    // hide spinner so user doesn't think something is still processing
    if (spinner) spinner.style.display = 'none';
}

function removeServerDownAlert() {
    const existing = document.querySelector('#server-down-alert');
    if (existing) existing.remove();
}

function stopPollingAndStartReconnect() {
    // stop the normal polling
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
    }

    // if already trying to reconnect, don't start another
    if (reconnectionInterval) return;

    // try to ping the server every X seconds (choose a sane interval)
    reconnectionInterval = setInterval(async () => {
        try {
            // minimal attempt: HEAD or GET on status root
            const r = await fetch(`/status/${taskId}`, { cache: 'no-store' });
            if (r.ok) {
                // server restored
                clearInterval(reconnectionInterval);
                reconnectionInterval = null;
                removeServerDownAlert();

                // resume polling and immediately run one poll to sync UI
                if (!pollingInterval) {
                    // run one pollStatus immediately ‚Äî ensure you don't recursively call setInterval from inside pollStatus
                    pollStatus().catch(err => console.warn('pollStatus after reconnect failed', err));
                    pollingInterval = setInterval(pollStatus, 2000);
                }
            } else {
                console.debug('reconnect attempt: server still not OK', r.status);
            }
        } catch (e) {
            console.debug('reconnect attempt failed (still offline)', e);
        }
    }, 3000); // try every 3s ‚Äî tweak as needed
}

function stopReconnectLoop() {
    if (reconnectionInterval) {
        clearInterval(reconnectionInterval);
        reconnectionInterval = null;
    }
}

 

        
    </script>

 

{% endblock %}
    
    <!-- Logs panel markup inserted outside scripts so elements exist for JS references -->
    {% block after_body %}{% endblock %}
<!--
[PROMPT_SUGGESTION]How can I deploy this Flask application to a cloud service like Heroku or Vercel?[/PROMPT_SUGGESTION]
[PROMPT_SUGGESTION]Modify the background task processing to use a more robust job queue like Celery with Redis.[/PROMPT_SUGGESTION]
